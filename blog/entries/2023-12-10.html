<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../prism.css">
    <script src="../prism.js"></script>
    <title>Dev Log</title>
</head>
<body>
    <header>
        <h1>Handling Collision</h1>
        <p>Published on: <time datetime="2023-12-10">December 10, 2023</time></p>
    </header>

    <section id="content">
        <p>I'm on the third day of porting InfiniteAbyss to Defold from Unity. Today I'm working on collision, movement, and the level generation. 
            I added a vector in the init for collision to correct the player</p>
        <pre class="line-numbers"><code class="language-lua">
-- player.script
function init(self)
    -- code omitted for brevity
    -- correction vector for collision
    self.correction = vmath.vector3()
end
        </code></pre>

        <p>Next, In the update function, I reset the correction vector to zero. 
            This is so after the player isn't touching anything, the correction vector will reset.
        </p>
        <pre class="line-numbers"><code class="language-lua">
-- player.script
function update(self, dt)
    -- code omitted for brevity
    -- reset correction
    self.correction = vmath.vector3()
end
        </code></pre>

        <p>Finally, in the on_message function, I handle the collision. 
            I get the distance from the collision, and if it's greater than zero, 
            I project the accumulated correction onto the penetration vector. 
            If the projection is less than one, I get the compensation and apply it. 
            Then I accumulate the correction done.
        </p>
        <pre class="line-numbers"><code class="language-lua">
-- player.script
function on_message(self, message_id, message, sender)
	if debugCollision then print("Collision on_message") end
	-- Handle collision
	if message_id == hash("contact_point_response") then
		-- Get the info needed to move out of collision. We might
		-- get several contact points back and have to calculate
		-- how to move out of all of them by accumulating a
		-- correction vector for this frame:
		if message.distance > 0 then
			-- First, project the accumulated correction onto
			-- the penetration vector
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				-- Only care for projections that does not overshoot.
				local comp = (message.distance - message.distance * proj) * message.normal
				-- Apply compensation
				go.set_position(go.get_position() + comp)
				-- Accumulate correction done
				self.correction = self.correction + comp
			end
		end
	end
end
                    </code></pre>
                    <p>We have to set up the player collisionobject to Kinematic, and the level collisionobject to Static. And voila, just like that, we now have collision.</p>
                    <img src="./2023-12-10.gif" alt="Character collides with tilemap." width="300" height="auto">


                    <p> 
                        Next we want to make our player move left and right.
                         We add a local variable to say how far the player can swim left and right.
                          then in the init we initialize the current width to zero and the direction the player is facing to zero.
                           This is so we know what direction to move the player and how far they can move.
                    </p>
                    <pre class="line-numbers"><code class="language-lua">
-- player.script

local swimWidth = 125

function init(self)
    -- code omitted for brevity
    self.currentWidth = 0 -- Initialize the current width
    self.facing = 0 -- direction player is facing 0 is right 1 is left
    -- code omitted for brevity
end
                    </code></pre>
                    <p> 
                        In the update function we check if the player is touching the screen and if they are we move them in the direction they are facing.
                    </p>
                    <pre class="line-numbers"><code class="language-lua">
function update(self, dt)
    -- code omitted for brevity
	-- move the player in the direction they are facing
	if self.is_touched and self.facing == 1  and self.currentWidth < swimWidth then
		local deltaX = math.min(speed * dt, swimWidth - self.currentWidth)
		go.set_position(vmath.vector3(go.get_position().x - deltaX, go.get_position().y, 0))
		self.currentWidth = self.currentWidth + deltaX
	elseif self.is_touched and self.facing == 0 and self.currentWidth < swimWidth then
		local deltaX = math.min(speed * dt, swimWidth - self.currentWidth)
		go.set_position(vmath.vector3(go.get_position().x + deltaX, go.get_position().y, 0))
		self.currentWidth = self.currentWidth + deltaX
	end
    -- code omitted for brevity
end
                    </code></pre>
                    <p> 
                        In the on_input function we add some logic to keep track of the direction the player is facing. At the end we reset the current width and the direction the player is facing.
                    </p>
                    <pre class="line-numbers"><code class="language-lua">
function on_input(self, action_id, action)
    if action_id == hash("touch") then
        if action.pressed then
        -- code omitted for brevity
            local position = go.get_position()
            if action.x < position.x then
                self.facing = 1
            else
                self.facing = 0
            end
            
        elseif action.released then
        -- code omitted for brevity
            self.currentWidth = 0
            self.touchDirection = nil
        end
    end
end
</code></pre>
<p>And now our player can swim left and right. 
    We are going to refine the movement so it plays better, but for now this will allow us to test moving around the level.</p>
<img src="./2023-12-10-1.gif" alt="Character moves left and right." width="300" height="auto">

<!-- Camera follows player-->
<p> Now we want our camera to follow the player. 
    Although we could just make a camera and attach it to our player,
     we are going to use a library to make things a little easier.
    We are going to use the Orthographic library created by Bj√∂rn Ritzl.
     https://github.com/britzl/defold-orthographic
</p>
<img src="./2023-12-10.png" alt="Character moves left and right." width="300" height="auto">
<p>We added the camera to our main collection. The touch is still buggy since it is using the coordinates from the screen instead of the world, but this library will let us fix that easy.
    We also started working on the level generation. Right now we are just figuring out how to get the bounds of the tilemap and use that to make two walls.
</p>
<pre class="line-numbers"><code class="language-lua">
-- Map.script
local debugMode = true

if debugMode then print("Map Debug") end

-- Load tile source and set it to a tile map
go.property("my_tile_source", resource.tile_source("/Terrain/Level.tilesource"))

function init(self)
    if debugMode then print(("Tile Source Path: %s"):format(self.my_tile_source)) end
    go.set("#Level", "tile_source", self.my_tile_source)

    -- Assuming the tilemap is named "Level"
    local url = "#Level"

    -- Get the bounds of the tilemap
    local tilemap = tilemap  -- Add this line
    local x, y, width, height = tilemap.get_bounds(url)

    -- Print the bounds
    if debugMode then print(("Tilemap Bounds - X: %d, Y: %d, Width: %d, Height: %d"):format(x, y, width, height)) end

    -- get the tile nu.
    local tileno = tilemap.get_tile(url, "layer1", x, y)
    if debugMode then print(("Get tile - , tileno: %d"):format(tileno)) end

    -- set the tile to that num
    --tilemap.set_tile(url,"layer1",x,y,1)

    -- Set all tiles to a specific tile index (1 in this case)
    for i = x, 100 do
        tilemap.set_tile(url, "layer1", x, i, 1)
        if debugMode then print(("set tile for left side - x: %d, y: %d"):format(x, i)) end

        i = i + 1
    end
    -- Set all tiles to a specific tile index (1 in this case)
    for i = x, 100 do
        tilemap.set_tile(url, "layer1", width-1, i, 1)
        if debugMode then print(("set tile for right side - x: %d, y: %d"):format(width-1, i)) end
        i = i + 1
    end

    
end    
</code></pre>
<p>Here you can see the camera following the player, as well as the walls be generated with our Map.script</p>
<img src="./2023-12-10-2.gif" alt="Camera follows character moves left and right." width="300" height="auto">

    </section>

    <section id="back-to-blog">
        <a href="../../blog/blog-index.html">Back to blog index</a>
    </section>
</body>
</html>
